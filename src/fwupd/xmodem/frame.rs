use crc::{CRC_16_XMODEM, Crc};

const ONES_COMPLEMENT: u8 = 0xFF;
const SOH: u8 = 0x01;
pub const EOT: u8 = 0x04;
pub const ACK: u8 = 0x06;
pub const NAK: u8 = 0x15;
pub const PAYLOAD_SIZE: usize = 128;
pub const PACKET_SIZE: usize = PAYLOAD_SIZE + 5;
pub type Payload = [u8; PAYLOAD_SIZE];
pub type PacketBytes = heapless::Vec<u8, PACKET_SIZE>;

const CRC: Crc<u16> = Crc::<u16>::new(&CRC_16_XMODEM);

/// Represents an Xmodem packet structure.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Frame {
    soh: u8,
    blk: u8,
    cmp: u8,
    data: Payload,
    chk: u16,
}

impl Frame {
    /// Creates a new Xmodem packet with the given block number and data.
    #[allow(clippy::missing_const_for_fn)]
    pub fn new(blk: u8, data: Payload) -> Self {
        Self {
            soh: SOH,
            blk,
            cmp: blk ^ ONES_COMPLEMENT,
            chk: CRC.checksum(&data),
            data,
        }
    }

    /// Returns the bytes of the packet.
    pub fn into_bytes(self) -> PacketBytes {
        let mut vec = PacketBytes::new();
        vec.push(self.soh).expect("Buffer overflow. This is a bug.");
        vec.push(self.blk).expect("Buffer overflow. This is a bug.");
        vec.push(self.cmp).expect("Buffer overflow. This is a bug.");
        vec.extend(self.data);
        vec.extend(self.chk.to_be_bytes());
        vec
    }
}

#[cfg(test)]
mod tests {
    use super::CRC;

    const TEST_DATA: &[u8] = &[
        0xEB, 0x17, 0xA6, 0x03, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x00, 0xF4, 0x0A, 0x0A, 0xF4, 0x1C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD, 0x03, 0x03, 0xFD, 0xB0, 0x00, 0x00, 0x00,
        0x00, 0x40, 0x00, 0x00, 0xA0, 0x39, 0x00, 0x20, 0xF1, 0x97, 0x02, 0x00, 0x91, 0xA4, 0x00,
        0x00, 0x95, 0xA4, 0x00, 0x00, 0xA7, 0x0A, 0x0A, 0x01, 0x00, 0x42, 0x00, 0x00, 0x04, 0x18,
        0x0F, 0xAC, 0x20, 0x69, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x86, 0x03, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn test_crc() {
        assert_eq!(CRC.checksum(TEST_DATA), 0xAAEE);
    }
}
