use crc::{CRC_16_XMODEM, Crc};

const ONES_COMPLEMENT: u8 = 0xFF;
const SOH: u8 = 0x01;
const PAYLOAD_OFFSET: usize = 3;
pub const EOT: u8 = 0x04;
pub const ACK: u8 = 0x06;
pub const NAK: u8 = 0x15;
pub const PAYLOAD_SIZE: usize = 128;
pub const PACKET_SIZE: usize = PAYLOAD_SIZE + 5;
pub type Payload = [u8; PAYLOAD_SIZE];
pub type PacketBytes = [u8; PACKET_SIZE];

const CRC: Crc<u16> = Crc::<u16>::new(&CRC_16_XMODEM);

/// Represents an Xmodem packet structure.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Frame {
    soh: u8,
    blk: u8,
    cmp: u8,
    data: Payload,
    chk: u16,
}

impl Frame {
    /// Creates a new Xmodem packet with the given block number and data.
    pub const fn new(blk: u8, data: Payload) -> Self {
        Self {
            soh: SOH,
            blk,
            cmp: blk ^ ONES_COMPLEMENT,
            chk: CRC.checksum(&data),
            data,
        }
    }

    /// Returns the bytes of the packet.
    pub fn into_bytes(self) -> PacketBytes {
        let mut result = [0; PACKET_SIZE];
        result[0] = self.soh;
        result[1] = self.blk;
        result[2] = self.cmp;
        result[PAYLOAD_OFFSET..PAYLOAD_SIZE + PAYLOAD_OFFSET].copy_from_slice(&self.data);
        result[PACKET_SIZE - 2..PACKET_SIZE].copy_from_slice(&self.chk.to_le_bytes());
        result
    }
}

#[cfg(test)]
mod tests {
    use super::CRC;

    const TEST_DATA: &[u8] = &[
        0xEB, 0x17, 0xA6, 0x03, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x00, 0xF4, 0x0A, 0x0A, 0xF4, 0x1C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD, 0x03, 0x03, 0xFD, 0xB0, 0x00, 0x00, 0x00,
        0x00, 0x40, 0x00, 0x00, 0xA0, 0x39, 0x00, 0x20, 0xF1, 0x97, 0x02, 0x00, 0x91, 0xA4, 0x00,
        0x00, 0x95, 0xA4, 0x00, 0x00, 0xA7, 0x0A, 0x0A, 0x01, 0x00, 0x42, 0x00, 0x00, 0x04, 0x18,
        0x0F, 0xAC, 0x20, 0x69, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x86, 0x03, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn test_crc() {
        assert_eq!(CRC.checksum(TEST_DATA), 0xAAEE);
    }
}
